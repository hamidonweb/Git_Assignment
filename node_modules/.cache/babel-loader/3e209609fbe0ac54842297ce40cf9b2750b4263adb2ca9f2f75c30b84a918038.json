{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = domToReact;\nvar react_1 = require(\"react\");\nvar attributes_to_props_1 = __importDefault(require(\"./attributes-to-props\"));\nvar utilities_1 = require(\"./utilities\");\nvar React = {\n  cloneElement: react_1.cloneElement,\n  createElement: react_1.createElement,\n  isValidElement: react_1.isValidElement\n};\n/**\n * Converts DOM nodes to JSX element(s).\n *\n * @param nodes - DOM nodes.\n * @param options - Options.\n * @returns - String or JSX element(s).\n */\nfunction domToReact(nodes, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var reactElements = [];\n  var hasReplace = typeof options.replace === 'function';\n  var transform = options.transform || utilities_1.returnFirstArg;\n  var _a = options.library || React,\n    cloneElement = _a.cloneElement,\n    createElement = _a.createElement,\n    isValidElement = _a.isValidElement;\n  var nodesLength = nodes.length;\n  for (var index = 0; index < nodesLength; index++) {\n    var node = nodes[index];\n    // replace with custom React element (if present)\n    if (hasReplace) {\n      var replaceElement = options.replace(node, index);\n      if (isValidElement(replaceElement)) {\n        // set \"key\" prop for sibling elements\n        // https://react.dev/learn/rendering-lists#rules-of-keys\n        if (nodesLength > 1) {\n          replaceElement = cloneElement(replaceElement, {\n            key: replaceElement.key || index\n          });\n        }\n        reactElements.push(transform(replaceElement, node, index));\n        continue;\n      }\n    }\n    if (node.type === 'text') {\n      var isWhitespace = !node.data.trim().length;\n      // We have a whitespace node that can't be nested in its parent\n      // so skip it\n      if (isWhitespace && node.parent && !(0, utilities_1.canTextBeChildOfNode)(node.parent)) {\n        continue;\n      }\n      // Trim is enabled and we have a whitespace node\n      // so skip it\n      if (options.trim && isWhitespace) {\n        continue;\n      }\n      // We have a text node that's not whitespace and it can be nested\n      // in its parent so add it to the results\n      reactElements.push(transform(node.data, node, index));\n      continue;\n    }\n    var element = node;\n    var props = {};\n    if (skipAttributesToProps(element)) {\n      (0, utilities_1.setStyleProp)(element.attribs.style, element.attribs);\n      props = element.attribs;\n    } else if (element.attribs) {\n      props = (0, attributes_to_props_1.default)(element.attribs, element.name);\n    }\n    var children = void 0;\n    switch (node.type) {\n      case 'script':\n      case 'style':\n        // prevent text in <script> or <style> from being escaped\n        // https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html\n        if (node.children[0]) {\n          props.dangerouslySetInnerHTML = {\n            __html: node.children[0].data\n          };\n        }\n        break;\n      case 'tag':\n        // setting textarea value in children is an antipattern in React\n        // https://react.dev/reference/react-dom/components/textarea#caveats\n        if (node.name === 'textarea' && node.children[0]) {\n          props.defaultValue = node.children[0].data;\n        } else if (node.children && node.children.length) {\n          // continue recursion of creating React elements (if applicable)\n          children = domToReact(node.children, options);\n        }\n        break;\n      // skip all other cases (e.g., comment)\n      default:\n        continue;\n    }\n    // set \"key\" prop for sibling elements\n    // https://react.dev/learn/rendering-lists#rules-of-keys\n    if (nodesLength > 1) {\n      props.key = index;\n    }\n    reactElements.push(transform(createElement(node.name, props, children), node, index));\n  }\n  return reactElements.length === 1 ? reactElements[0] : reactElements;\n}\n/**\n * Determines whether DOM element attributes should be transformed to props.\n * Web Components should not have their attributes transformed except for `style`.\n *\n * @param node - Element node.\n * @returns - Whether the node attributes should be converted to props.\n */\nfunction skipAttributesToProps(node) {\n  return utilities_1.PRESERVE_CUSTOM_ATTRIBUTES && node.type === 'tag' && (0, utilities_1.isCustomComponent)(node.name, node.attribs);\n}","map":{"version":3,"names":["exports","default","domToReact","react_1","require","attributes_to_props_1","__importDefault","utilities_1","React","cloneElement","createElement","isValidElement","nodes","options","reactElements","hasReplace","replace","transform","returnFirstArg","_a","library","nodesLength","length","index","node","replaceElement","key","push","type","isWhitespace","data","trim","parent","canTextBeChildOfNode","element","props","skipAttributesToProps","setStyleProp","attribs","style","name","children","dangerouslySetInnerHTML","__html","defaultValue","PRESERVE_CUSTOM_ATTRIBUTES","isCustomComponent"],"sources":["D:\\mydata\\my_projects\\zode\\assignment\\hamid_webApp\\node_modules\\html-react-parser\\src\\dom-to-react.ts"],"sourcesContent":["import type { DOMNode, Element, Text } from 'html-dom-parser';\nimport type { JSX } from 'react';\nimport { cloneElement, createElement, isValidElement } from 'react';\n\nimport type { Props } from './attributes-to-props';\nimport attributesToProps from './attributes-to-props';\nimport type { HTMLReactParserOptions } from './types';\nimport {\n  canTextBeChildOfNode,\n  isCustomComponent,\n  PRESERVE_CUSTOM_ATTRIBUTES,\n  returnFirstArg,\n  setStyleProp,\n} from './utilities';\n\nconst React = {\n  cloneElement,\n  createElement,\n  isValidElement,\n} as const;\n\n/**\n * Converts DOM nodes to JSX element(s).\n *\n * @param nodes - DOM nodes.\n * @param options - Options.\n * @returns - String or JSX element(s).\n */\nexport default function domToReact(\n  nodes: DOMNode[],\n  options: HTMLReactParserOptions = {},\n): string | JSX.Element | JSX.Element[] {\n  const reactElements = [];\n\n  const hasReplace = typeof options.replace === 'function';\n  const transform = options.transform || returnFirstArg;\n  const { cloneElement, createElement, isValidElement } =\n    options.library || React;\n\n  const nodesLength = nodes.length;\n\n  for (let index = 0; index < nodesLength; index++) {\n    const node = nodes[index];\n\n    // replace with custom React element (if present)\n    if (hasReplace) {\n      let replaceElement = options.replace!(node, index) as JSX.Element;\n\n      if (isValidElement(replaceElement)) {\n        // set \"key\" prop for sibling elements\n        // https://react.dev/learn/rendering-lists#rules-of-keys\n        if (nodesLength > 1) {\n          replaceElement = cloneElement(replaceElement, {\n            key: replaceElement.key || index,\n          });\n        }\n\n        reactElements.push(transform(replaceElement, node, index));\n        continue;\n      }\n    }\n\n    if (node.type === 'text') {\n      const isWhitespace = !node.data.trim().length;\n\n      // We have a whitespace node that can't be nested in its parent\n      // so skip it\n      if (\n        isWhitespace &&\n        node.parent &&\n        !canTextBeChildOfNode(node.parent as Element)\n      ) {\n        continue;\n      }\n\n      // Trim is enabled and we have a whitespace node\n      // so skip it\n      if (options.trim && isWhitespace) {\n        continue;\n      }\n\n      // We have a text node that's not whitespace and it can be nested\n      // in its parent so add it to the results\n      reactElements.push(transform(node.data, node, index));\n      continue;\n    }\n\n    const element = node as Element;\n    let props: Props = {};\n\n    if (skipAttributesToProps(element)) {\n      setStyleProp(element.attribs.style, element.attribs);\n      props = element.attribs;\n    } else if (element.attribs) {\n      props = attributesToProps(element.attribs, element.name);\n    }\n\n    let children: ReturnType<typeof domToReact> | undefined;\n\n    switch (node.type) {\n      case 'script':\n      case 'style':\n        // prevent text in <script> or <style> from being escaped\n        // https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html\n        if (node.children[0]) {\n          props.dangerouslySetInnerHTML = {\n            __html: (node.children[0] as Text).data,\n          };\n        }\n        break;\n\n      case 'tag':\n        // setting textarea value in children is an antipattern in React\n        // https://react.dev/reference/react-dom/components/textarea#caveats\n        if (node.name === 'textarea' && node.children[0]) {\n          props.defaultValue = (node.children[0] as Text).data;\n        } else if (node.children && node.children.length) {\n          // continue recursion of creating React elements (if applicable)\n          children = domToReact(node.children as Text[], options);\n        }\n        break;\n\n      // skip all other cases (e.g., comment)\n      default:\n        continue;\n    }\n\n    // set \"key\" prop for sibling elements\n    // https://react.dev/learn/rendering-lists#rules-of-keys\n    if (nodesLength > 1) {\n      props.key = index;\n    }\n\n    reactElements.push(\n      transform(createElement(node.name, props, children), node, index),\n    );\n  }\n\n  return reactElements.length === 1 ? reactElements[0] : reactElements;\n}\n\n/**\n * Determines whether DOM element attributes should be transformed to props.\n * Web Components should not have their attributes transformed except for `style`.\n *\n * @param node - Element node.\n * @returns - Whether the node attributes should be converted to props.\n */\nfunction skipAttributesToProps(node: Element): boolean {\n  return (\n    PRESERVE_CUSTOM_ATTRIBUTES &&\n    node.type === 'tag' &&\n    isCustomComponent(node.name, node.attribs)\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}